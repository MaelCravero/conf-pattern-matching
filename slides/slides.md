---
title: "How to do bad pattern-matching in C++"
subtitle: "and generate 917 lines of warnings per line of code"
author: "Mael Cravero"
institute: "EPITA - Tiger Compiler"
topic: "Tiger Compiler"
linkstyle: bold
aspectratio: 169
date: December 2nd 2021
section-titles: true
toc: false
...

Introduction
============

### Hey Vsauce

- Mael Cravero
- ACDC, YAKA, ACU
- Tiger Maintainer
- Strong interest in **static analysis**, **compilation** and **programming
  languages** in general

\vfill
\pause

#### Warning

We will talk about OCaml.
\pause
I like OCaml.

### A bit of context

- About a year ago, I was working on Tiger Compiler a lot
- TC's instruction selector was **old** (last meaningful modification was 2005)
- **Modern C++** is way different from 2005 C++

How can this section of the project be modernized?

### Instruction selection in a nutshell

![Instruction selection as depicted by *Modern Compiler Implementation in
ML*](img/instruction_selection.png){height=100%}

### The main idea

- Instruction selection is basically **pattern-matching**...
\pause
- ...but there is no pattern-matching in C++...
\pause
- ...so we used an external program (MonoBURG) to generate nested switches

\vfill
\pause

#### Goal

**Replace** non-idiomatic pattern-matching generated by MonoBURG with
**idiomatic** modern C++ using `std::visit` and `std::variant`.


### Goals of this presentation

1. C++ and compilation basics
\pause
2. Pattern-matching concepts
\pause
3. Emulate basic pattern-matching in C++
\pause
4. Static vs dynamic polymorphism
\pause
5. Try to do smart things and fail miserably

C++ basics
==========

### Quick history

![Daemon prince Bjarne Stroustrup](img/stroustrup.jpeg){width=20%}

- Created by **Bjarne Stroustrup** in the 80s, first standard in **1998**
- C++ is a compiled multi-paradigm programming language with "0-cost
  abstractions"
- First started as an "object-oriented C", now a somewhat high-level language
  with many (*many*) features
- Strong distinction between "old" C++ (pre C++11) and **modern** C++

### "I like C++" and other hilarious jokes you can tell yourself

![C++ in a nutshell](img/cpp.jpeg){width=50%}

### What's a compiler? Can I eat it?

To put it simply, a *compiler* is a software which goal is to generate
**lower-level** intermediate code or machine code from **higher-level** source
code.

- `gcc` generates *assembly* from *C*
- `ocamlc` generates *OCaml bytecode* from *OCaml*
- `rustc` generates *llvm-ir* from *Rust*

C++ is most often compiled by `g++` or `clang++` (or `msvc` on Windows).

\pause
\vfill

#### Why such errors?

C++ is a complex language which compiles through code generation.
Errors often happen deep within generated code, hence the awfully long errors.

### Hello world!

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello there" << std::endl;
    return 0;
}
```
\vfill
#### Compile and run

```
42sh$ g++ -Wall -Wextra -pedantic -std=c++20 hello.cc -o hello
42sh$ ./hello
Hello there
```

### Generics and polymorphism

A *generic* function is a function which can take multiple types as arguments.

\pause

This concept is linked to **polymorphism**: representing multiple types with a
common symbol.

Polymorphism can be:

- **static**, *i.e.* processed at compile-time
- **dynamic**, *i.e.* processed at run-time

\pause

In C++, genericity can be expressed mostly through **subtyping**, which is
linked to static and dynamic polymorphism, and **templates**, which are only
linked to static polymorphism.

### Subtyping classes

In object-oriented programming, one can create a **subclass** which *inherits* from
another class. This is a form of **subtyping**.

This subclass can be used in any context where the superclass is expected, but
not the reverse.

\vfill
#### Example
See `code/cpp-basics/subtypes.cc`

### Static type, dynamic type

Depending on the context, an object can have multiple types. We differentiate
its **static type**, its type at compile-time within a specific context, from
its **dynamic type**, the type with which it is created which can be accessed at
run-time.

\pause

The dynamic type of an object can be accessed through **virtual methods**. This
is the basis of patterns like visitors (which we won't talk about).

\vfill
#### Example
See `code/cpp-basics/static-vs-dynamic.cc`

### Templates and monomorphization

The other type of genericity allowed by C++ is **templates**.

Templates allow for any class or function to be parametrized by a specific type.
This will then generate appropriate code through a process known as
*monomorphization*.

Templates are **fully static**, they are processed at compile-time only and do
not exist at run-time.

\vfill

#### Quick note
Templates are the main mechanism causing the awful error messages of C++.
1091 lines of error for a one-line function? Thank templates.

### Template instanciation

```cpp
template <typename T>
void f() // f is parametrized by any type T
{}

int main()
{
    f<int>();   // generate a function specialized for int
    f<float>(); // generate a function specialized for float

    return 0;
}
```

### The `auto` C++20 syntax

In C++20, one can write the following:
```cpp
template <typename T>
void print(T v) { std::cout << v; }
```

as such:

```cpp
void print(auto v) { std::cout << v; }
```

This is only *syntactic sugar*, those two writings are exactly the same! The
`auto` syntax is monomorphized too!


Pattern-matching for dummies
============================

### OCaml > all

![A camel](img/gringo.jpg){width=20%}

\pause

- **OCaml** is the best language taught in EPITA
\pause
- Fight me
\pause

One particularly nice feature: its **pattern-matching** system.

### Basic matching

### Algebraic types

### The killer feature

Back to C++
===========

### Switches save the day!

### Well, only if processing primitive types...

### Remember algebraic types?

### The almighty `std::visit`

### Default cases thanks to templates

### Basic solution

Hacking C++ to emulate OCaml (poorly)
=====================================

### What about destructuring?

### A hint of an answer

Where things go wrong
=====================

### Monomorphization does not suppress warnings...

### ...or errors

### Subtyping gets rid of auto!

### ...but not in TC

### What about destructuring?

### So we must template everything?

### Damn

Conclusion
==========
