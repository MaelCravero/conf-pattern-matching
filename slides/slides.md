---
title: "How to do bad pattern-matching in C++"
subtitle: "and generate 917 lines of warnings per line of code"
author: "Mael Cravero"
institute: "EPITA - Tiger Compiler"
topic: "Tiger Compiler"
linkstyle: bold
aspectratio: 169
date: December 2021
section-titles: true
toc: false
...

Introduction
============

### Hey Vsauce

- Mael Cravero
- ACDC, YAKA, ACU
- Tiger Maintainer
- Strong interest in **static analysis**, **compilation** and **programming
  languages** in general

\vfill
\pause

#### Warning

We will talk about OCaml.
\pause
I like OCaml.

### A bit of context

- About a year ago, I was working on Tiger Compiler a lot
- TC's instruction selector was **old** (last meaningful modification was 2005)
- **Modern C++** is way different from 2005 C++

How can this section of the project be modernized?

### Instruction selection in a nutshell

![Instruction selection as depicted by *Modern Compiler Implementation in
ML*](img/instruction_selection.png){height=100%}

### The main idea

- Instruction selection is basically **pattern-matching**...
\pause
- ...but there is no pattern-matching in C++...
\pause
- ...so we used an external program (MonoBURG) to generate nested switches

\vfill
\pause

#### Goal

**Replace** non-idiomatic pattern-matching generated by MonoBURG with
**idiomatic** modern C++ using `std::visit` and `std::variant`.


### Goals of this presentation

1. C++ and compilation basics
\pause
2. Pattern-matching concepts
\pause
3. Emulate basic pattern-matching in C++
\pause
4. Static vs dynamic polymorphism
\pause
5. Try to do smart things and fail miserably

C++ basics
==========

### Quick history

![Daemon prince Bjarne Stroustrup](img/stroustrup.jpeg){width=20%}

- Created by **Bjarne Stroustrup** in the 80s, first standard in **1998**
- C++ is a compiled multi-paradigm programming language with "0-cost
  abstractions"
- First started as an "object-oriented C", now a somewhat high-level language
  with many (*many*) features
- Strong distinction between "old" C++ (pre C++11) and **modern** C++

### "I like C++" and other hilarious jokes you can tell yourself

![C++ in a nutshell](img/cpp.jpeg){width=50%}

### What's a compiler? Can I eat it?

To put it simply, a *compiler* is a software which goal is to generate
**lower-level** intermediate code or machine code from **higher-level** source
code.

- `gcc` generates *assembly* from *C*
- `ocamlc` generates *OCaml bytecode* from *OCaml*
- `rustc` generates *llvm-ir* from *Rust*

C++ is most often compiled by `g++` or `clang++` (or `msvc` on Windows).

\pause
\vfill

#### Why such errors?

C++ is a complex language which compiles through code generation.
Errors often happen deep within generated code, hence the awfully long errors.

### Hello world!

```cpp
#include <iostream>

int main()
{
    std::cout << "Hello there" << std::endl;
    return 0;
}
```
\vfill
#### Compile and run

```
42sh$ g++ -Wall -Wextra -pedantic -std=c++20 hello.cc -o hello
42sh$ ./hello
Hello there
```

### Generics and polymorphism

A *generic* function is a function which can take multiple types as arguments.

\pause

This concept is linked to **polymorphism**: representing multiple types with a
common symbol.

Polymorphism can be:

- **static**, *i.e.* processed at compile-time
- **dynamic**, *i.e.* processed at run-time

\pause

In C++, genericity can be expressed mostly through **subtyping**, which is
linked to static and dynamic polymorphism, and **templates**, which are only
linked to static polymorphism.

### Subtyping classes

In object-oriented programming, one can create a **subclass** which *inherits* from
another class. This is a form of **subtyping**.

This subclass can be used in any context where the superclass is expected, but
not the reverse.

\vfill
#### Example
See `code/cpp-basics/subtypes.cc`

### Static type, dynamic type

Depending on the context, an object can have multiple types. We differentiate
its **static type**, its type at compile-time within a specific context, from
its **dynamic type**, the type with which it is created which can be accessed at
run-time.

\pause

The dynamic type of an object can be accessed through **virtual methods**. This
is the basis of patterns like visitors (which we won't talk about).

\vfill
#### Example
See `code/cpp-basics/static-vs-dynamic.cc`

### Templates and monomorphization

The other type of genericity allowed by C++ is **templates**.

Templates allow for any class or function to be parametrized by a specific type.
This will then generate appropriate code through a process known as
*monomorphization*.

Templates are **fully static**, they are processed at compile-time only and do
not exist at run-time.

\vfill

#### Quick note
Templates are the main mechanism causing the awful error messages of C++.
1091 lines of error for a one-line function? Thank templates.

### Template instanciation

```cpp
template <typename T>
void f() // f is parametrized by any type T
{}

int main()
{
    f<int>();   // generate a function specialized for int
    f<float>(); // generate a function specialized for float

    return 0;
}
```

### C++20 `auto` syntax

In C++20, one can write the following:
```cpp
template <typename T>
void print(T v) { std::cout << v; }
```

as such:

```cpp
void print(auto v) { std::cout << v; }
```

This is only *syntactic sugar*, those two writings are exactly the same! The
`auto` syntax is monomorphized too!


Pattern-matching for dummies
============================

### OCaml > all

![A camel](img/gringo.jpg){width=20%}

\pause

- **OCaml** is the best language taught in EPITA
\pause
- Fight me
\pause

One particularly nice feature: its **pattern-matching** system.

### Don't trust me?

![It's literally written in the
doc](img/fonctionnalite_vraiment_cool.png){width=80%}

### Basic matching

```ocaml
let is_the_answer n =
  match n with
  | 42 -> "The answer"
  | _ -> "Not the answer"
;;

let () = print_endline (is_the_answer 42)
```

### Algebraic types

Algebraic types are **composite types** common in functional programming. There
are two main types:

- **product types**: type $\alpha$ *and* type $\beta$ *and*...
- **sum type**: type $\alpha$ *or* type $\beta$ *or*...

\pause

In more common terms, a tuple-like type or a union-like type.

### An example

```ocaml
type a_or_b = A | B

let string_of_a_or_b x =
  match x with
  | A -> "A"
  | B -> "B"
;;

let () = print_endline (string_of_a_or_b A) (* "A" *)
```

### It gets better

```ocaml
type a_or_b = A | B of int

let string_of_a_or_b x =
  match x with
  | A -> "A"
  | B n when n = 42 -> "The answer"
  | B _ -> "B"
;;

let () = print_endline (string_of_a_or_b (B 21)) (* "B" *)
```

### The killer feature

OCaml pattern-matching is **very expressive**, thanks to:

- **wildcard** patterns
\pause
- **guards** to check specific conditions
\pause
- **destructuration** to match on inner fields

\pause
\vfill
#### Compiler safety
Thanks to exhaustiveness checks, you cannot write a `match` with unusable or
missing cases. This greatly reduces the number of errors you could write.

### Back to our problem

Let's put it all in practice!

```ocaml
type tree = Int of int | Mem of tree | Move of tree * tree
let rec traverse = function ...
let matcher = function ...
```

\pause
Last OCaml example, I swear.

\vfill
#### Example

See `code/pattern-matching/match-tree.ml`

Back to C++
===========

### Switches save the day!

```cpp
#include <iostream>

int main()
{
    int n = 42;
    switch (n)
    {
    case 42:
        std::cout << "The answer" << std::endl;
        break;
    default:
        std::cout << "Not the answer" << std::endl;
    }
    return 0;
}
```

### Well, only if processing primitive types...

```cpp
#include <iostream>

int main() {
    std::string s = "Hello there...";
    switch (s) {
    case "Hello there...":
        std::cout << "General Kenobi" << std::endl;
    default:
        break;
    }
    return 0;
}
```

\pause
This **does not** compile. `error: switch quantity not an integer`

### Remember algebraic types?

Algebraic types exist in C++ since **C++11** for product types (`std::tuple`)
and **C++17** for sum types (`std::variant`).

\pause
\vfill

```cpp
#include <string>
#include <tuple>
#include <variant>

int main()
{
    std::tuple<int, std::string> p = {0, "zero"};
    std::variant<int, std::string> s_int = 42;
    std::variant<int, std::string> s_string = "forty-two";
    return std::get<int>(s_int);
}
```

### Static or dynamic?

What happens there?

```cpp
#include <string>
#include <variant>

int main()
{
    std::variant<int, std::string> s = "forty-two";
    return std::get<int>(s);
}
```

\pause
It does compile.
\pause
But we get a runtime error. `std::get: wrong index for variant`

### Naive variants using unions

Examples inspired from [cppreference/union](https://en.cppreference.com/w/cpp/language/union).

```cpp
struct my_variant
{
    enum {INT, STRING} tag;
    union
    {
        int i;
        std::string s;
    };
};
```

\pause
Obviously, `std::variant` is quite more complicated (`clang`'s `libcxx` [variant
header](https://github.com/llvm/llvm-project/blob/main/libcxx/include/variant)
is 1775 lines) but you get the idea.

### Dispatching on variants

Remember, it's all **run-time**.

```cpp
void print(const my_variant& v)
{
    switch(s.tag)
    {
        case my_variant::INT: std::cout << v.i << '\n'; break;
        case my_variant::STRING: std::cout << v.s << '\n'; break;
    }
}

int main()
{
    my_variant v = {my_variant::INT, 42};
    print(v);
}
```

### The almighty `std::visit`

For `std::variant`, we can use `std::visit`.

```cpp
#include <variant>
#include <iostream>

int main()
{
    std::variant<int, std::string> v = 42;
    std::visit([](auto x){ std::cout << x << '\n';}, v);
}
```

### Where is Waldo?

Did you catch it? A **template** was hiding in the previous slide...

\pause

Let's desugar the lambda.

```cpp
struct Lambda {
    void operator()(auto x) {
        std::cout << x << '\n';
    }
};

int main() {
    std::variant<int, std::string> v = 42;
    std::visit(Lambda(), v);
}
```

### Warning: explicit

It was there all along!

```cpp
struct Lambda {
    template <typename T>
    void operator()(T x) {
        std::cout << x << '\n';
    }
};

int main() {
    std::variant<int, std::string> v = 42;
    std::visit(Lambda(), v);
}
```

### Our first real matcher

```cpp
struct A {};
struct B {};

struct Is_A
{
    bool operator()(A) { return true; }
    bool operator()(B) { return false; }
};

int main()
{
    std::variant<A, B> v = A();
    return std::visit(Is_A(), v); // returns 1
}
```

### Default cases thanks to templates

- `std::visit` needs its visitor to handle **every possible type** for the
  variant visited
- This could get quite annoying if we had to explicitly handle every possible
  case

\pause
\vfill
```cpp
using TreeVariant = misc::variant<rExp, rStm>;
using ExpVariant =
  misc::variant<rBinop, rCall, rConst, rEseq, rMem, rName, rTemp>;
using StmVariant =
  misc::variant<rCjump, rJump, rLabel, rMove, rSeq, rSxp>;
```
\vfill
\pause

Templates can be used for this kind of generation: if we use a **templated
method** in the visitor, it will **generate code** for every otherwise unmatched
case.

\pause
This is our poor man's wildcard. \pause Sort of.

### As easy as that

```cpp
struct A {};
struct B {};

struct Is_A
{
    bool operator()(A) { return true; }
    bool operator()(auto) { return false; }
};

int main()
{
    std::variant<A, B, int, float> v = 42;
    return std::visit(Is_A(), v); // returns 0
}
```

### Basic solution

Time to put it all together!

Let's see a simple recreation of the structure we use for instruction
scheduling.

\vfill

#### Example
See `code/cpp-matching/match-tree.cc`

Hacking C++ to emulate OCaml (poorly)
=====================================

### What about destructuring?

### A hint of an answer

Where things go wrong
=====================

### Using the dynamic type in variants

### Bootleg but it works

### Monomorphization does not suppress warnings...

### ...or errors

### Subtyping gets rid of auto!

### ...but not in TC

### What about destructuring?

### So we must template everything?

### Damn

Conclusion
==========
